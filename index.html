<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title> PDF –  20 ans</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    header {
      background-color: #003366;
      color: #fff;
      padding: 10px;
      text-align: center;
    }
    footer {
      background-color: #003366;
      color: #fff;
      padding: 10px;
      text-align: center;
      position: fixed;
      bottom: 0;
      width: 100%;
    }
    #pdf-content {
      margin: 60px 20px 60px 20px; /* espace pour header et footer */
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      table-layout: fixed;
    }
    table, th, td {
      border: 1px solid #666;
    }
    th, td {
      padding: 8px;
      text-align: center;
      white-space: nowrap; /* Pour garder chiffres et € sur une même ligne */
    }
    th {
      background-color: #f2f2f2;
    }
    #download-pdf, #process-pdf {
      margin: 20px;
      padding: 10px 20px;
      font-size: 16px;
    }
    #file-container {
      text-align: center;
      margin: 20px;
    }
  </style>
</head>
<body>
  <!-- Sélection du PDF -->
  <div id="file-container">
    <input type="file" id="pdf-selector" accept="application/pdf">
    <button id="process-pdf">Charger PDF et générer la nouvelle page</button>
  </div>

  <!-- Contenu généré qui sera converti en PDF (initialement caché) -->
  <div id="pdf-content" style="display:none;">
    <header>
      <!-- Ces valeurs seront mises à jour avec le nom et l’adresse extraits de la page1 -->
      <h1>Nom du client</h1>
      <p>Adresse du client</p>
    </header>
    <main>
      <table id="simulation-table">
        <thead>
          <tr>
            <th>Année</th>
            <th>Facture Sans PV</th>
            <th>Économies</th>
            <th>Gains Revente</th>
            <th>Prime (année 2)</th>
            <th>Facture Avec PV</th>
            <th>Total économies</th>
            <th>Financement</th>
            <th>Cumul économies</th>
          </tr>
        </thead>
        <tbody>
          <!-- Les lignes seront générées dynamiquement -->
        </tbody>
      </table>
    </main>
    <footer>
      <p>Document non contractuel – Page générée automatiquement</p>
    </footer>
  </div>

  <!-- Bouton de téléchargement (initialement caché) -->
  <div style="text-align: center;">
    <button id="download-pdf" style="display:none;">Télécharger PDF</button>
  </div>

  <!-- Inclusion des librairies html2pdf.js et PDF.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
  <script>
    let pdfFilename = 'Plan de financement & nom du client.pdf'; // Valeur par défaut

    // Fonction utilitaire pour nettoyer les tokens (ex: fusionner nombre et €)
    function cleanTokens(tokens) {
      return tokens.map(t => t.replace(/\s*€\s*/, "€").trim());
    }

    // Fonction pour reconstruire une ligne du tableau dans le nouvel ordre
    // Ici, nous supposons que l'ordre original extrait (pour chaque ligne) est :
    // [Année, Facture Sans PV, Économies, Autoconso, Gains, Prime, Facture Avec PV, Total économies, (optionnel Cumul economies)]
    // Et nous voulons obtenir :
    // [Année, Facture Sans PV, Économies, Gains Revente (issu d'Autoconso), Prime (année 2) (issu de Gains, inversion), Facture Avec PV (issu de Prime, inversion), Total économies, Financement, Cumul économies]
    // Pour la ligne des totaux (commençant par "Totaux"), on ne calcule pas financement ni cumul.
    function reassembleRow(tokens, financementValue, rowIndex) {
      // Pour les lignes de données (non totaux), on suppose au moins 8 tokens
      // Réorganiser en fonction de notre mapping :
      // Note : Cette logique peut être adaptée selon la structure réelle du PDF.
      if(tokens[0].toLowerCase().startsWith("totaux")) {
        // Ligne totale : on renvoie les tokens tels quels et on ajoute deux colonnes vides
        return [...tokens, "", ""];
      } else {
        // Nouvelle ligne
        // Nouvelle répartition proposée :
        // new[0] = tokens[0] : Année
        // new[1] = tokens[1] : Facture Sans PV
        // new[2] = tokens[2] : Économies
        // new[3] = tokens[3] : Gains Revente (anciennement Autoconso)
        // new[4] = tokens[4] : Prime (année 2) (issu de Gains, inversion)
        // new[5] = tokens[5] : Facture Avec PV (issu de Prime, inversion) – ici on suppose que la colonne "Prime" et "Facture Avec PV" sont interverties
        // new[6] = tokens[6] : Total économies (si présent, sinon tokens[7])
        // On ignore d’éventuels tokens supplémentaires et on recalculera "Cumul économies"
        let totalEconomies = tokens[6] || tokens[7] || "0€";
        // Pour Financement et Cumul économies, on ne les calcule que pour les 20 premières années (rowIndex < 20)
        let financement = "";
        let cumul = "";
        if(rowIndex < 20) {
          financement = (rowIndex < 6) ? financementValue + "€" : "";
          // Pour le cumul, si financement existe, on soustrait (on retire le symbole pour calculer)
          let totalNum = parseFloat(totalEconomies.replace("€", "").replace(",", "."));
          let financementNum = (rowIndex < 6) ? parseFloat(financementValue) : 0;
          cumul = ((totalNum - financementNum).toFixed(2)) + "€";
        }
        return [
          tokens[0], // Année
          tokens[1], // Facture Sans PV
          tokens[2], // Économies
          tokens[3], // Gains Revente (issu d'Autoconso)
          tokens[4], // Prime (année 2) (issu de Gains, inversion)
          tokens[5], // Facture Avec PV (issu de Prime, inversion)
          totalEconomies, // Total économies
          financement,    // Financement
          cumul           // Cumul économies
        ];
      }
    }

    // Fonction pour créer dynamiquement le corps du tableau à partir des lignes extraites
    function buildTableBody(rowsArray, financementValue) {
      const tbody = document.querySelector("#simulation-table tbody");
      tbody.innerHTML = ""; // vider d'éventuelles lignes existantes
      rowsArray.forEach((rowText, index) => {
        // Nettoyer le texte : fusionner le nombre et le symbole €
        rowText = rowText.replace(/(\d)\s*€/g, "$1€");
        // Séparer par espaces
        let tokens = rowText.split(/\s+/);
        tokens = cleanTokens(tokens);
        // Si on a suffisamment de tokens (au moins 7 pour une ligne de données ou commence par Totaux)
        if(tokens.length >= 7 || tokens[0].toLowerCase().startsWith("totaux")) {
          const newRow = reassembleRow(tokens, financementValue, index);
          const tr = document.createElement("tr");
          newRow.forEach(cellText => {
            const td = document.createElement("td");
            td.textContent = cellText;
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        }
      });
    }

    document.getElementById("process-pdf").addEventListener("click", function() {
      const fileInput = document.getElementById("pdf-selector");
      if (fileInput.files.length === 0) {
        alert("Veuillez sélectionner un fichier PDF.");
        return;
      }
      const file = fileInput.files[0];
      const fileReader = new FileReader();
      fileReader.onload = function() {
        const typedarray = new Uint8Array(this.result);
        pdfjsLib.getDocument(typedarray).promise.then(function(pdf) {
          // On extrait d'abord les informations de la page 1 (client + tableau)
          pdf.getPage(1).then(function(page1) {
            return page1.getTextContent().then(function(textContent) {
              // Pour simplifier, on collecte toutes les chaînes non vides dans un tableau
              const allTexts = textContent.items.map(item => item.str).filter(str => str.trim() !== "");
              // Supposons que les deux premières chaînes correspondent au nom et à l’adresse du client
              const clientName = allTexts[0] ? allTexts[0].trim() : "Nom du client";
              const clientAddress = allTexts[1] ? allTexts[1].trim() : "Adresse du client";
              // Mettre à jour l'en-tête
              document.querySelector("header h1").textContent = clientName;
              document.querySelector("header p").textContent = clientAddress;
              // Construction du nom du fichier PDF
              pdfFilename = `Plan de financement & ${clientName}.pdf`;
              
              // Ensuite, on tente d'extraire les lignes du tableau.
              // Ici, on recherche dans allTexts les lignes commençant par un chiffre (pour les années) ou "Totaux"
              const tableRows = allTexts.filter(str => /^\d+/.test(str) || str.toLowerCase().startsWith("totaux"));
              // Pour déboguer, vous pouvez afficher tableRows dans la console :
              console.log("Lignes extraites du tableau :", tableRows);
              
              return tableRows;
            });
          }).then(function(tableRows) {
            // Parallèlement, on extrait le coût de l'installation depuis la page 2 pour le calcul du financement
            pdf.getPage(2).then(function(page2) {
              page2.getTextContent().then(function(textContent2) {
                const textItems2 = textContent2.items.map(item => item.str);
                const fullText2 = textItems2.join(" ");
                const regex = /Coût de l'installation\s*:\s*([\d\s,.]+)\s*€/i;
                const match = fullText2.match(regex);
                let installationCost = 0;
                if (match && match[1]) {
                  installationCost = parseFloat(match[1].replace(/\s/g, '').replace(',', '.'));
                } else {
                  alert("Impossible de trouver le coût de l'installation dans le PDF (page 2).");
                }
                // Calcul du financement
                const financementValue = (installationCost * 1.837 / 100 * 12).toFixed(2);
                // Construire le tableau avec les lignes extraites et le financement
                buildTableBody(tableRows, financementValue);
                // Afficher le contenu généré et le bouton de téléchargement
                document.getElementById("pdf-content").style.display = "block";
                document.getElementById("download-pdf").style.display = "inline-block";
              });
            });
          });
        }).catch(function(error) {
          console.error("Erreur lors du chargement du PDF : ", error);
          alert("Erreur lors du chargement du PDF.");
        });
      };
      fileReader.readAsArrayBuffer(file);
    });

    // Génération et téléchargement du PDF en mode paysage
    document.getElementById("download-pdf").addEventListener("click", function () {
      const opt = {
        margin: 0.5,
        filename: pdfFilename,
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: { scale: 2 },
        jsPDF: { unit: 'in', format: 'letter', orientation: 'landscape' }
      };
      const element = document.getElementById("pdf-content");
      html2pdf().set(opt).from(element).save();
    });
  </script>
</body>
</html>
